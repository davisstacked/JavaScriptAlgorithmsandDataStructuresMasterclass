<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script defer src="./app.js"></script>
    <link rel="stylesheet" href="./main.css">
    <title>JavaScript Algorithms and Data Structures Masterclass</title>
</head>
<body>
    <h1>Notes</h1>
    <h2>Don't Panic!</h2>

    <h3 class="header">Big O Notation</h3>

    <h4>TIMING OUR CODE 2.5</h4>
    <h5>What does better mean?</h5>
    <ul>
        <li>Faster?</li>
        <li>Less memory-intensive?</li>
        <li>More readable?</li>
    </ul>

    <p>miliseconds is a 1000 seconds. how we count time in computer speed - miliseconds</p>

    <h5>The Problem with Time</h5>
    <ul>
        <li>Different machines will record different times</li>
        <li>The same machine will record different times!</li>
        <li>For fast algorithms, speed measurements may not be precise enough?</li>
    </ul>

    <h4>COUNTING OPERATIONS 2.6</h4>
    <p>Depending on what we count, the number of operations can be as low as 2n or as high as 5n +2. But regardless of the exact number, the number of operations grows roughly <span>proportionally with n</span></p>

    <h4>Visualizing Time Complexities 2.7</h4>

    <a href="https://rithmschool.github.io/function-timer-demo/">Performance Tracker for Big O that professor created - runs functions from this section of the course</a>

    <p>A microsecond is one millionth of a second</p>

    <p>number of operations performed negatively impacts speed of performance</p>

    <h4>OFFICIAL INTRO TO BIG O 2.7</h4>
    <p>Big O Notation is a way to formalize fuzzy counting</p>
    <p>It allows us to talk formally about how the runtime of an algorithm grows as the inputs grow.</p>
    <p>We don't care about details - only broad trends.</p>

    <h5>Big O Definition</h5>
    <p>We say that an algorithm is O(f(n)) if the number of simple operations the computer has to do is eventually less than a constant times f(n), as n increases.</p>
    <ul>
        <li>f(n) could be linear (f(n) = n)</li>
        <li>f(n) could be quadratic (f(n) = n2)</li>
        <li>f(n) could be constant (f(n) = 1</li>
        <li>f(n) could be something entirely different!</li>
    </ul>

    <p>In mathematics, the term <strong>quadratic</strong> describes something that pertains to squares, to the operation of squaring, to terms of the second degree, or equations or formulas that involve such terms. Quadratus is Latin for square.</p>

    <p>When we're talking about Big O we're talking about The Worst Case Scenario - the upper-bound for run-time</p>

    <p>** O(n) operation inside of an O(n) operation (like nested loops) is O(n2) - an exponential curve which has a steep run-time increase.</p>

    <h4>SIMPLIFYING BIG O EXPRESSIONS 2.9 </h4>

    <ul>
        <h5>Constants Don't Matter</h5>
        <li>O(2n) simplifies down to O(n)</li>
        <li>O(2n) simplifies down to O(n)</li>
        <li>O(500) simplifies to O(1)</li>
        <li>O(13n^2) simplifies to O(n^2)</li>
    </ul>

    <ul>
        <h5>Smaller Terms Don't Matter</h5>
        <li>O(n + 10) simplifies to O(n)</li>
        <li>O(1000n + 50) simplifies to O(n)</li>
        <li>O(n^2 + 5n + 8) simplifies to O(n^2)</li>
    </ul>

    <ul>
        <h5>Big O Shorthands</h5>
        <li>Arithmetic operations are constant</li>
        <li>variable assignment is constant</li>
        <li>Accessing elements in an array (by index) or object (by key) is constant</li>
        <li>In a loop, the complexity is the length of the loop times the complexity of whatever happens inside of the loop.</li>
    </ul>

    <img src="./Screen Shot 2021-02-16 at 2.09.39 PM.png" alt="Big O Notation">

    <h4>Space Complexity</h4>

    <p>So far, we've been focused on <strong>time complexity:</strong> how can we analyze the <span>runtime</span> of an algorithm as the size of the inputs increases?</p>
    <p>We can also use big O notation to analyze <strong>space complexity:</strong> how much additional memory do we need to allocate in order to run the code in our algorithm?</p>

    <h6>What about the inputs?</h6>
    <p>Sometimes you'll hear the term <strong>auxiliary space complexity</strong> to refer to space required by the algorithm, not including space taken up by the inputs.</p>
    <p>Unless otherwise noted, when we talk about space complexity, technically we'll be talking about auxiliary space complexity. (we're focusing on what happens inside of the algorithm.)</p>

    <h5>Space Complexity in JS - Rules of Thumb</h5>
    <ul>
        <li>Most primitives (booleans, numbers, undefined, null) are constant space</li>
        <li>Strings require O(n) space (where n is the string length)</li>
        <li>Reference types are generally O(n), where n is the length (for arrays) or the number of keys (for objects)</li>
    </ul>

    <h4>Logs and Section Recap</h4>

    <h6>Logarithms</h6>
    <p>We've encountered some of the most common complexities: O(1), O(n), O(n^2) <br>
    Sometimes big O expressions involved more complex mathematical expressions. One that appears more often than you might like is the logarithm!</p>

    <p>the logarithm of a number roughly measures the number of times you can divide that number by 2 <strong>before you get a value that's less than or equal to one.</strong></p>

    <h5>Logarithm Complexity - logarithmic time complexity is great!</h5>
    <p>Certain searching algorithms have logarithmic time complexity.</p>
    <p>Efficient sorting algorithms involve logarithms.</p>
    <p>Recursion sometimes involves logarithmic space complexity.</p>

    <h3>Recap</h3>
    <ul>
        <li>To analyze the performance of an algorithm, we use Big O Notation</li>
        <li>Big O Notation can give us a high level understanding of the time or space complexity of an algorithm</li>
        <li>Big O notation doesn't care about precision, only about general trends (linear? quadratic? constant?)</li>
        <li>The time or space complexity (as measured by Big O) depends only on the algorithm, not the hardware used to run the algorithm.</li>
    </ul>

    <h2 class="header">Section 4: Problem Solving Approach</h2>

    <h4>Introduction to Problem Solving</h4>
    <p><strong>Algorithm:</strong>a process or set of steps to accomplish a certain task.</p>

    <ul>
        <li>Understand the Problem</li>
        <li>Explore Concrete Examples</li>
        <li>Break It Down</li>
        <li>Solve/Simplify</li>
        <li>Look Back and Refactor</li>
    </ul>
</body>
</html>